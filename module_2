# MODULE 2 â€” CORE ARCHITECTURE & INTERNAL WORKING
(Git + Docker Deep Internals)
---
# ğŸ”¥ PART 1 â€” GIT INTERNAL ARCHITECTURE
When you run:
```
git init
```
It creates a hidden folder:
```
.git/
```
That folder is the entire Git database.
Letâ€™s inspect its structure:
```
.git/
â”œâ”€â”€ HEAD
â”œâ”€â”€ config
â”œâ”€â”€ description
â”œâ”€â”€ index
â”œâ”€â”€ objects/
â”‚   â”œâ”€â”€ info/
â”‚   â””â”€â”€ pack/
â”œâ”€â”€ refs/
â”‚   â”œâ”€â”€ heads/
â”‚   â””â”€â”€ tags/
â””â”€â”€ logs/
```
Everything Git does is manipulating this folder.
Your working directory is just a view.
---
# ğŸ§  KEY MENTAL MODEL
Git has 3 main areas:
```
Working Directory
       â†“
Staging Area (Index)
       â†“
Repository (.git objects)
```
---
# ğŸ”¹ 1. WORKING DIRECTORY
This is your actual project files.
Example:
```
project/
 â”œâ”€â”€ app.js
 â””â”€â”€ package.json
```
This is normal filesystem.
---
# ğŸ”¹ 2. STAGING AREA (INDEX)
File:
```
.git/index
```
This is a binary file.
It stores:
* File path
* File hash (SHA)
* File metadata
The staging area is NOT a folder.
It is a **binary snapshot builder**.
---
# ğŸ”¹ 3. REPOSITORY (OBJECT DATABASE)
Stored inside:
```
.git/objects/
```
This is where Git stores actual content.
---
# ğŸ”¥ PART 2 â€” GIT OBJECT MODEL
Git has only 4 object types:
1. Blob
2. Tree
3. Commit
4. Tag
Everything is built from these.
---
# ğŸ“¦ 1. BLOB (Binary Large Object)
Blob stores:
* File content only
* No filename
* No metadata
Example:
If file contains:
```
hello world
```
Git compresses it and stores it as blob:
```
.git/objects/ab/cd1234...
```
Directory naming logic:
First 2 characters of SHA â†’ folder
Remaining â†’ file name
Example:
```
ab1234567890...
```
Stored as:
```
.git/objects/ab/1234567890...
```
Why?
Performance.
Too many files in one folder slows filesystem.
---
# ğŸŒ³ 2. TREE OBJECT
Tree represents a directory.
It stores:
* File name
* Blob hash
* File mode (permissions)
Example tree:
```
app.js â†’ blob SHA1
package.json â†’ blob SHA2
```
Tree points to blobs.
Tree can also point to another tree (subfolder).
---
# ğŸ“ 3. COMMIT OBJECT
Commit stores:
* Pointer to tree
* Parent commit
* Author
* Timestamp
* Message
Example structure:
```
Commit
 â”œâ”€â”€ Tree: abc123
 â”œâ”€â”€ Parent: def456
 â”œâ”€â”€ Author
 â””â”€â”€ Message
```
This creates a linked list.
Actually a Directed Acyclic Graph (DAG).
---
# ğŸ”– 4. TAG OBJECT
Used to mark commits (like releases).
---
# ğŸ”¥ VISUALIZATION
```
Commit C
  â†“
Tree T
  â†“
Blob A
Blob B
```
And commit C points to previous commit B.
Graph:
```
A â†’ B â†’ C
```
This is immutable chain.
---
# ğŸ” WHY IMMUTABLE?
Because hash depends on content.
If you change blob:
* Blob hash changes
* Tree hash changes
* Commit hash changes
So history is cryptographically chained.
---
# ğŸ”¥ PART 3 â€” STAGING AREA INTERNALS
When you run:
```
git add app.js
```
What happens internally?
1. Git reads file
2. Computes SHA hash
3. Creates blob object
4. Stores blob in .git/objects
5. Updates .git/index to map filename â†’ blob hash
Important:
Nothing is committed yet.
Index is like:
> â€œNext snapshot to be committedâ€
---
# ğŸ”¥ PART 4 â€” BRANCHING INTERNALS
Branches are NOT copies.
They are pointers.
Check:
```
.git/refs/heads/main
```
Open that file:
It contains:
```
abc123commitSHA
```
Thatâ€™s it.
Branch = pointer to commit.
When you commit:
1. New commit created
2. Branch pointer updated to new commit
Graph:
Before:
```
main â†’ A â†’ B
```
After commit:
```
main â†’ A â†’ B â†’ C
```
---
# ğŸ”¥ HEAD POINTER
File:
```
.git/HEAD
```
It contains:
```
ref: refs/heads/main
```
Meaning:
HEAD points to branch.
If detached HEAD:
```
HEAD contains commit SHA directly
```
Now HEAD not attached to branch.
---
# ğŸ”¥ PART 5 â€” MERGE INTERNALS
Suppose:
```
A â†’ B â†’ C  (main)
     \
      D â†’ E  (feature)
```
When merging feature into main:
Git finds:
Common ancestor = B
Then performs:
3-way merge:
* Base: B
* Current: C
* Incoming: E
Git compares diffs:
B â†’ C
B â†’ E
If no conflict:
Auto merge.
If conflict:
Marks file with:
```
<<<<<<< HEAD
=======
>>>>>>> feature
```
Because Git cannot decide.
---
# ğŸ”¥ REBASE INTERNALS
Rebase rewrites history.
Instead of merge:
```
A â†’ B â†’ C
     \
      D â†’ E
```
Rebase feature onto main:
Git:
1. Finds commits D and E
2. Removes them
3. Re-applies them on top of C
Result:
```
A â†’ B â†’ C â†’ D' â†’ E'
```
D' and E' are new commits.
New SHA.
Because parent changed.
---
# ğŸ”¥ PART 6 â€” DOCKER ARCHITECTURE
High-level:
```
Docker CLI
    â†“
Docker Daemon (dockerd)
    â†“
containerd
    â†“
runc
    â†“
Linux Kernel
```
---
# ğŸ”¹ DOCKER CLIENT
Command line tool:
```
docker run
docker build
docker pull
```
Sends REST API requests to daemon.
---
# ğŸ”¹ DOCKER DAEMON
Background service.
Responsibilities:
* Manage images
* Manage containers
* Networking
* Volumes
* Registry communication
Runs as root.
---
# ğŸ”¹ CONTAINERD
Handles container lifecycle.
* Pull image
* Create container
* Manage runtime
---
# ğŸ”¹ RUNC
Low-level runtime.
Implements:
OCI (Open Container Initiative) spec.
Uses:
* Namespaces
* cgroups
* chroot
* pivot_root
---
# ğŸ”¥ PART 7 â€” UNION FILESYSTEM (OverlayFS)
Docker images are layered.
Example:
```
Layer 1: Ubuntu base
Layer 2: Node installed
Layer 3: App code
```
OverlayFS merges them:
```
Upper layer (writeable)
Lower layers (read-only)
```
When container writes file:
Copy-on-write happens.
File copied to upper layer.
---
# ğŸ”¥ PART 8 â€” NAMESPACES DEEP DIVE
Linux namespaces types:
1. PID â€” process isolation
2. NET â€” network isolation
3. MNT â€” filesystem isolation
4. UTS â€” hostname isolation
5. IPC â€” inter-process communication isolation
6. USER â€” user ID isolation
Container runtime configures these.
Example:
Container sees:
```
PID 1
```
But host sees:
```
PID 34567
```
---
# ğŸ”¥ PART 9 â€” CGROUPS DEEP DIVE
Cgroups control:
* CPU shares
* Memory limit
* Block IO
* PIDs count
Example:
```
docker run --memory=512m
```
Kernel enforces limit.
If container exceeds:
OOM killer kills process.
---
# ğŸ”¥ PART 10 â€” END-TO-END FLOW
When you run:
```
docker run nginx
```
Flow:
1. CLI sends request to daemon
2. Daemon checks image locally
3. If not found â†’ pull from registry
4. Download layers
5. Create container metadata
6. containerd creates container
7. runc configures namespaces
8. Kernel creates isolated process
9. nginx runs as PID 1 inside namespace
Container = Process with isolation.
---
# ğŸ”¥ MEMORY MODEL COMPARISON
VM:
Each VM:
* Separate kernel memory
* Separate OS memory
* More overhead
Container:
* Shared kernel memory
* Only process memory used
* Less overhead
---
# ğŸ”¥ CRITICAL ARCHITECTURE INSIGHT
Git:
Content-addressable object store.
Docker:
Layered filesystem + namespace isolation.
Both rely heavily on:
Immutability + hashing + OS primitives.
---
# MODULE 2 â€” PRACTICE EXERCISES
1. Manually explore .git/objects after commit.
2. Delete branch file in refs and observe behavior.
3. Simulate merge conflict and inspect DAG.
4. Inspect container process using:
```
ps aux
docker inspect
```
5. View namespaces using:
```
lsns
```
---
# INTERVIEW QUESTIONS
* Explain Git object model.
* What is staging area internally?
* How does Git store branches?
* Explain 3-way merge algorithm.
* Difference between merge and rebase internally?
* Explain Docker architecture layers.
* What is containerd?
* What is runc?
* What is OverlayFS?
* Explain PID namespace.
